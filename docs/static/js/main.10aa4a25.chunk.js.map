{"version":3,"sources":["components/AddCategory.js","helpers/getGifs.js","components/GifGridItem.js","components/GifGrid.js","hooks/useFetchGifs.js","GiftExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setInputValue","onSubmit","e","preventDefault","trim","length","cats","type","value","onChange","target","getGifs","category","a","url","encodeURI","fetch","resp","json","data","gifs","map","img","id","title","images","downsized_medium","GifGridItem","className","src","alt","GifGrid","loading","state","setState","useEffect","then","imgs","useFetchGifs","GiftExpertApp","categories","ReactDOM","render","document","getElementById"],"mappings":"2MAMaA,EAAc,SAAC,GAAqB,IAApBC,EAAmB,EAAnBA,cAAmB,EACRC,mBAAS,IADD,mBACrCC,EADqC,KACzBC,EADyB,KAuBxC,OAEA,sBAAMC,SAtBS,SAACC,GAChBA,EAAEC,iBAECJ,EAAWK,OAAOC,OAAO,IAExBR,GAAc,SAAAS,GAAI,OAAGP,GAAH,mBAAkBO,OACpCN,EAAc,MAgBlB,SACI,uBAAOO,KAAK,OACJC,MAAOT,EACPU,SAXU,SAACP,GACnBF,EAAcE,EAAEQ,OAAOF,a,+BCtBtBG,EAAO,uCAAG,WAAOC,GAAP,uBAAAC,EAAA,6DAETC,EAFS,yFAE6EC,UAAUH,GAFvF,sBAGII,MAAMF,GAHV,cAGTG,EAHS,gBAIKA,EAAKC,OAJV,uBAIRC,EAJQ,EAIRA,KAEDC,EAAOD,EAAKE,KAAK,SAAAC,GAAQ,IAAD,EAC1B,MAAO,CACHC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MACXV,IAAG,UAAEQ,EAAIG,cAAN,aAAE,EAAYC,iBAAiBZ,QAV3B,kBAkBRM,GAlBQ,4CAAH,sDCEPO,EAAc,SAAC,GAG5B,EAH8BJ,GAG7B,IAHiCC,EAGlC,EAHkCA,MAAOV,EAGzC,EAHyCA,IAIrC,OACI,sBAAKc,UAAU,yCAAf,UAEI,qBAAKC,IAAKf,EAAKgB,IAAKN,IACpB,uBACA,4BAAIA,QCPHO,EAAU,SAAC,GAAgB,IAAfnB,EAAc,EAAdA,SAAc,ECHX,SAACA,GAC5B,IAAD,EAC8Bd,mBAAS,CAC/BqB,KAAK,GACLa,SAAQ,IAHhB,mBACWC,EADX,KACkBC,EADlB,KAmBI,OAdJC,qBAAU,WACFxB,EAAQC,GAAUwB,MAAK,SAACC,GAChBH,EAAS,CACLf,KAAKkB,EACLL,SAAQ,SAGtB,CAACpB,IAOIqB,EDDsBK,CAAa1B,GAA/Ba,EAhBwB,EAgB7BN,KAAaa,EAhBgB,EAgBhBA,QAInB,OACI,qCACD,oBAAIJ,UAAU,oCAAd,SAAmDhB,IACnDoB,GAAW,mBAAGJ,UAAU,kCAAb,yBACV,qBAAKA,UAAU,YAAf,SAEKH,EAAOJ,KACP,SAAAC,GAAQ,OAAS,cAAC,EAAD,eACkBA,GADAA,EAAIC,aEQpCgB,EAlCI,WACnB,IAAD,EACwCzC,mBAAS,CAAC,cADlD,mBACW0C,EADX,KACuB3C,EADvB,KAWI,OACI,qCACA,6CACA,cAAC,EAAD,CAAaA,cAAeA,IAC5B,uBACA,uBACA,uBAEA,6BAEK2C,EAAWnB,KAAI,SAAAT,GAAQ,OACvB,cAAC,EAAD,CAAwBA,SAAUA,GAApBA,YCxB3B6B,IAASC,OACP,cAAC,EAAD,IACAC,SAASC,eAAe,W","file":"static/js/main.10aa4a25.chunk.js","sourcesContent":["import React, {useState} from 'react'\r\nimport PropTypes from 'prop-types'\r\n\r\n/*Se encarga de mostrar los escrito en el input y agregarlo \r\na la liosta dse categorias al presionar enter */\r\n\r\nexport const AddCategory = ({setCategories}) => {\r\n    const [inputValue, setInputValue] = useState('');\r\n        \r\n    const handleSubmit=(e)=>{ //Al usar el setCategories aquí, nos aseguramos que se renderice al ahcer enter\r\n        e.preventDefault(); // porque el evento devuelve un formulario, es para que no recargue\r\n        \r\n        if(inputValue.trim().length>2) //El .trim borra los espacios\r\n        {\r\n            setCategories(cats=>[inputValue, ...cats]);\r\n            setInputValue('');\r\n        }\r\n        //Set categories modifica el arreglo de categorias, este se puede pasar como argumento pero al ser \r\n        //Esta funcion parte del mismo hook, se pueden llamar como argumento en el callback\r\n        //es decir laa variable ya viaja como argumento en la función\r\n\r\n    }\r\n\r\n    const handleInputChange = (e)=>{        \r\n            setInputValue(e.target.value);            \r\n            \r\n    }\r\n\r\n    \r\n        return (        \r\n        \r\n        <form onSubmit={handleSubmit}>\r\n            <input type=\"text\"\r\n                    value={inputValue}\r\n                    onChange = { handleInputChange }\r\n            />\r\n\r\n        </form>           \r\n        //</>\r\n    )\r\n}\r\n\r\n\r\nAddCategory.propTypes = {\r\n    setCategories: PropTypes.func.isRequired\r\n}","//Etsa función de extrajo de GifGrid\r\n//Se encarga de hacer la petición http y devolver el contenido.\r\nexport const getGifs = async (category)=>\r\n    {\r\n        const url=`http://api.giphy.com/v1/gifs/search?api_key=QaYllLgOhjES5eWjofPuHqhKiEaAbhGu&q=${encodeURI(category)}&limit=10`;\r\n        const resp = await fetch(url);\r\n        const {data}= await resp.json();\r\n        //console.log(data);\r\n        const gifs = data.map( img => {\r\n            return {\r\n                id: img.id,\r\n                title: img.title,\r\n                url: img.images?.downsized_medium.url\r\n            }\r\n\r\n        });\r\n        \r\n        //El signo de interrogación sirve para que consulte la url solo si vienen imagenes\r\n        //setImages(gifs); Esto establecia los datos el useState para renderizar pero como\r\n        //se separo entonces solo se devolerá el gifs\r\n        return gifs;\r\n    }\r\n","import React from 'react';\r\n\r\n// export const GifGridItem = ( props )=>  // El props se usa por constumbre,\r\n//Pero su uso es común\r\nexport const GifGridItem = ( {id, title, url})=>  // En este caso se están mandando \r\n//las propiedades de forma independiente por lo que los podemos recibir \r\n//desetructurando, lo que hace que ssea mas directo el uso de cada propiedad\r\n{\r\n    return (\r\n        <div className=\"card animate__animated animate__fadeIn\">\r\n            {/* props.title */}\r\n            <img src={url} alt={title} />\r\n            <br />\r\n            <p>{title}</p>\r\n        </div>\r\n    )\r\n}\r\n","import React from 'react';\r\nimport { useFetchGifs } from '../hooks/useFetchGifs';\r\n//import {useState, useEffect} from 'react';\r\n\r\nimport {GifGridItem} from './GifGridItem';\r\n\r\nexport const GifGrid = ({category}) => {\r\n    \r\n    \r\n     /* Recibe una función de flecha y un parametro, \r\n     al ser este un [] entonces el codigo de adentro solo se \r\n     ejecutará la primera vez que sea llamado el componente */\r\n    // useEffect(()=>{\r\n    //     getGifs(category).then(gifs=>setImages(gifs));\r\n    // }, [category]);\r\n    \r\n    \r\n    //getGif(); //Al presionar el botón y haber un cambio, el React lo detcta\r\n    //y renderiza todo nuevamente por lo que hace la petición cada vez, \r\n    //para evitarr eso usaremos el useEfect, al poder category al useEffect le decimos\r\n    //si la categoria cambia queremos voler a diparar el efecto\r\n\r\n   const {data:images, loading}= useFetchGifs(category);\r\n   //data:images es para renombrar, coomo se devulve data se deb usar para\r\n   //desestruturar y después le cambiamos el nombre\r\n    \r\n    return (\r\n        <>\r\n       <h3 className=\"animate__animated animate__fadeIn\">{category}</h3>\r\n      {loading && <p className=\"animate__animated animate__fash\">Cargando...</p>}\r\n        <div className=\"card-grid\">\r\n            {\r\n             images.map(\r\n             img=> { return ( <GifGridItem key={img.id}\r\n                                            {...img} /> //Es algo similar a la linea de abajo pero manda todos los objetos de forma directa.\r\n                                            //img={img} /> //En este caso se manda el objeto con las propiedades que se habían obtenido\r\n\r\n                           )\r\n                    }\r\n                )\r\n            }       \r\n        </div>\r\n        </>\r\n    )\r\n}\r\n","import {useState, useEffect} from 'react';\r\nimport {getGifs} from '../helpers/getGifs';\r\n\r\nexport const useFetchGifs = (category)=>\r\n{\r\n    const [state, setState] = useState({\r\n        data:[],\r\n        loading:true\r\n    });\r\nuseEffect(() => { // Recibe función de flecha que es donde se pondrá el codigo que se quiere controlar y un parametro de control\r\n        getGifs(category).then((imgs)=>{\r\n                setState({\r\n                    data:imgs,\r\n                    loading:false\r\n                });//del setState            \r\n        }); //del useEffect\r\n    },[category] )\r\n\r\n    // setTimeout(()=>{\r\n    //     setState({data:[1,2,3,4,5], loading:false}) //dento del setValor del Hook, para pasar mas de dos argumentos debemos utilizar {} y para asigna los :       \r\n    // }, //Parentesís del setTIme OUt\r\n    // 3000);\r\n\r\n    return state;\r\n}","import React, {useState} from 'react';\r\nimport { AddCategory } from './components/AddCategory';\r\nimport { GifGrid } from './components/GifGrid';\r\n\r\n/*Componente principal, donde se llaman a los otros componentes,\r\nSu proposito es mostrar imágenes gifs obtenidas de una API key*/\r\n\r\nconst GiftExpertApp=()=>\r\n{\r\n    const [categories, setCategories] = useState(['One Punch']);\r\n   \r\n   /*  const handleAdd=()=>\r\n    {\r\n        \r\n       \r\n        setCategories( [...categories,'Mis cacahuates']);\r\n        //setCategories( categos=> [...categos,'Mis cacahuates']);\r\n    } */\r\n\r\n    return (\r\n        <>\r\n        <h2>GifExpetApp</h2>\r\n        <AddCategory setCategories={setCategories} />\r\n        <hr />\r\n        <br />\r\n        <br />\r\n        \r\n        <ol>\r\n        { \r\n             categories.map(category => (\r\n             <GifGrid key={category} category={category}/> \r\n             ))// agrupación del return y del map\r\n        } \r\n        </ol>\r\n        \r\n            {/* No se puede usar un for porque necesita que regrese un valor pero podemos usar funciones que regresen un valo como el map */}\r\n        </>\r\n    );   \r\n}\r\n\r\n\r\nexport default  GiftExpertApp;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n//import reportWebVitals from './reportWebVitals';\n\nimport GiftExpertApp from './GiftExpertApp.js'\nReactDOM.render(\n  <GiftExpertApp />,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}